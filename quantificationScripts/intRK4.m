%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%% intRK4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
% Author: David Kelly
% Created: 2 September 2021
% Last Updated: 2 September 2021

% This function is used to numerically integrate the optimized trajectory
% of the BSLIP and VPP models

% INPUTS:
%   varS - Structure used for variable and post-optimization storage

% OUTPUTS:
%   varS - Structure used for variable and post-optimization storage

%% %%%%%%%%%%%%%%%%%%%%%%% Numerical Integration %%%%%%%%%%%%%%%%%%%%%%% %%

function varS = intRK4(varS)
    
    % Check if the optimized full state exists
    if isfield(varS.optims, 'stateFull')
    
        % Remove existing optimized full state values
        varS.optims = rmfield(varS.optims, 'stateFull');
    
    end
    
    % Grab number of states and number of time instances
    stateLen = length(varS.optims.state(1,:));
    instLen = length(varS.optims.state(:,1));
    
    % Grab phase duration
    phaseDur = varS.params.N;
    
    % Initialize full state vector
    varS.optims.stateFull(1,1:stateLen) = varS.optims.state(1,:);
    
    % Initialize gait cycle iterator
    cycle = 1;

    % For each time instance
    for i = 1:instLen

        % Check if current time instance is for double support 1
        if (i < ((4*(cycle - 1) + 1)*phaseDur))

            % Build non-state parameter vector
            pD = [varS.optims.stateFull(1,:), varS.optims.angOpt(1),...
                varS.optims.kOptLagDot(i), varS.optims.kOptLeadDot(i),...
                varS.optims.fOpt(1), varS.optims.timeOpt(1)];
            
            % Set phase identifier
            phase = 1;

            % For each finite element
            for j=1:varS.params.M

                % Check if using VPP or BSLIP template model
                if strcmp(varS.params.model, 'VPP')
                    
                    % Call RK4 integrator function to propogate states
                    k1D = intRK4VPP(varS, varS.optims.stateFull(end,:)',...
                        [pD, varS.optims.rVPPD(1)],...
                        varS.optims.uOpt(i), phase);
                    
                    k2D = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k1D)/2),...
                        [pD, varS.optims.rVPPD(1)],...
                        varS.optims.uOpt(i), phase);
                    
                    k3D = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k2D)/2),...
                        [pD, varS.optims.rVPPD(1)],...
                        varS.optims.uOpt(i), phase);
                    
                    k4D = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k3D)),...
                        [pD, varS.optims.rVPPD(1)],...
                        varS.optims.uOpt(i), phase);
                    
                else
                    
                    % Call RK4 integrator function to propogate states
                    k1D = intRK4BSLIP(varS,...
                        varS.optims.stateFull(end,:)',...
                        pD, varS.optims.uOpt(i), phase);
                    
                    k2D = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k1D)/2),...
                        pD, varS.optims.uOpt(i), phase);
                    
                    k3D = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k2D)/2),...
                        pD, varS.optims.uOpt(i), phase);
                    
                    k4D = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k3D)),...
                        pD, varS.optims.uOpt(i), phase);
                
                end

                % Propogate state variables based on RK4 algorithm
                varS.optims.stateFull(end+1,:) =...
                    varS.optims.stateFull(end,:) +...
                    (varS.params.dt/6)*(k1D' + 2*k2D' + 2*k3D' + k4D');

            end

        % Check if current time instance is for single support 1
        elseif (i < ((4*(cycle - 1) + 2)*phaseDur))

            % Build non-state parameter vector
            pS = [varS.optims.kOptLagDot(i); varS.optims.kOptLeadDot(i);...
                varS.optims.fOpt(2); varS.optims.timeOpt(2)];
            
            % Set phase identifier
            phase = 2;

            % For each finite element
            for j=1:varS.params.M

                % Check if using VPP or BSLIP template model
                if strcmp(varS.params.model, 'VPP')
                    
                    % Call RK4 integrator function to propogate states
                    k1S = intRK4VPP(varS, varS.optims.stateFull(end,:)',...
                        [pS; varS.optims.rVPPS(1)], [], phase);
                    
                    k2S = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k1S)/2),...
                        [pS; varS.optims.rVPPS(1)], [], phase);
                    
                    k3S = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k2S)/2),...
                        [pS; varS.optims.rVPPS(1)], [], phase);
                    
                    k4S = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k3S)),...
                        [pS; varS.optims.rVPPS(1)], [], phase);
                    
                else
                    
                    % Call RK4 integrator function to propogate states
                    k1S = intRK4BSLIP(varS,...
                        varS.optims.stateFull(end,:)',...
                        pS, [], phase);
                    
                    k2S = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k1S)/2),...
                        pS, [], phase);
                    
                    k3S = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k2S)/2),...
                        pS, [], phase);
                    
                    k4S = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k3S)),...
                        pS, [], phase);
                    
                end

                % Propogate state variables based on RK4 algorithm
                varS.optims.stateFull(end+1,:) =...
                    varS.optims.stateFull(end,:) +...
                    (varS.params.dt/6)*(k1S' + 2*k2S' + 2*k3S' + k4S');

            end

        % Check if current time instance is for double support 2
        elseif (i < ((4*(cycle - 1) + 3)*phaseDur))

            % Build non-state parameter vector
            pD = [varS.optims.stateFull(...
                (2*varS.params.N*varS.params.M + 1),:),...
                varS.optims.angOpt(2), varS.optims.kOptLagDot(i),...
                varS.optims.kOptLeadDot(i),...
                varS.optims.fOpt(2), varS.optims.timeOpt(3)];
            
            % Set phase identifier
            phase = 1;

            % For each finite element
            for j=1:varS.params.M

                % Check if using VPP or BSLIP template model
                if strcmp(varS.params.model, 'VPP')
                    
                    % Call RK4 integrator function to propogate states
                    k1D = intRK4VPP(varS, varS.optims.stateFull(end,:)',...
                        [pD, varS.optims.rVPPD(2)],...
                        varS.optims.uOpt(i-varS.params.N), phase);
                    
                    k2D = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k1D)/2),...
                        [pD, varS.optims.rVPPD(2)],...
                        varS.optims.uOpt(i-varS.params.N), phase);
                    
                    k3D = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k2D)/2),...
                        [pD, varS.optims.rVPPD(2)],...
                        varS.optims.uOpt(i-varS.params.N), phase);
                    
                    k4D = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k3D)),...
                        [pD, varS.optims.rVPPD(2)],...
                        varS.optims.uOpt(i-varS.params.N), phase);
                    
                else
                    
                    % Call RK4 integrator function to propogate states
                    k1D = intRK4BSLIP(varS,...
                        varS.optims.stateFull(end,:)',...
                        pD, varS.optims.uOpt(i-varS.params.N), phase);
                    
                    k2D = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k1D)/2),...
                        pD, varS.optims.uOpt(i-varS.params.N), phase);
                    
                    k3D = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k2D)/2),...
                        pD, varS.optims.uOpt(i-varS.params.N), phase);
                    
                    k4D = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k3D)),...
                        pD, varS.optims.uOpt(i-varS.params.N), phase);
                    
                end

                % Propogate state variables based on RK4 algorithm
                varS.optims.stateFull(end+1,:) =...
                    varS.optims.stateFull(end,:) +...
                    (varS.params.dt/6)*(k1D' + 2*k2D' + 2*k3D' + k4D');

            end

        % Check if current time instance is for single support 2    
        elseif (i < ((4*(cycle - 1) + 4)*phaseDur))

            % Build non-state parameter vector
            pS = [varS.optims.kOptLagDot(i);...
                varS.optims.kOptLeadDot(i); varS.optims.fOpt(3);...
                varS.optims.timeOpt(4)];
            
            % Set phase identifier
            phase = 2;

            % For each finite element
            for j=1:varS.params.M

                % Check if using VPP or BSLIP template model
                if strcmp(varS.params.model, 'VPP')
                    
                    % Call RK4 integrator function to propogate states
                    k1S = intRK4VPP(varS, varS.optims.stateFull(end,:)',...
                        [pS; varS.optims.rVPPS(2)], [], phase);
                    
                    k2S = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k1S)/2),...
                        [pS; varS.optims.rVPPS(2)], [], phase);
                    
                    k3S = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k2S)/2),...
                        [pS; varS.optims.rVPPS(2)], [], phase);
                    
                    k4S = intRK4VPP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k3S)),...
                        [pS; varS.optims.rVPPS(2)], [], phase);
                    
                else
                    
                    % Call RK4 integrator function to propogate states
                    k1S = intRK4BSLIP(varS,...
                        varS.optims.stateFull(end,:)',...
                        pS, [], phase);
                    
                    k2S = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k1S)/2),...
                        pS, [], phase);
                    
                    k3S = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k2S)/2),...
                        pS, [], phase);
                    
                    k4S = intRK4BSLIP(varS,...
                        (varS.optims.stateFull(end,:)' +...
                        (varS.params.dt*k3S)),...
                        pS, [], phase);
                    
                end

                % Propogate state variables based on RK4 algorithm
                varS.optims.stateFull(end+1,:) =...
                    varS.optims.stateFull(end,:) +...
                    (varS.params.dt/6)*(k1S' + 2*k2S' + 2*k3S' + k4S');

            end
            
        end
        
        % Check if end of gait cycle has been reached
        if (i/cycle) > 4*phaseDur
            
            % Update gait cycle iteration
            cycle = cycle + 1;
            
        end

    end

end
